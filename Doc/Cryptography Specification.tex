\documentclass[a4paper,10pt]{article}

\usepackage[utf8]{inputenc}
\usepackage[american]{babel}
\usepackage{fontenc}
\usepackage{hyperref}
\usepackage{enumerate}
\usepackage{paralist}

\input{Common}

\title{\longProduct{} Cryptography Specification}

\begin{document}

\maketitle
\tableofcontents

\section{Purpose}
This document specifies cryptographic parameters for the \longProduct{} system. These parameters include, but are not limited to, SSL cipher suits, RSA key length, registration 
code generation specification, etc.

\section{References}
For the project overview, see~\cite{project_spec}. For the supporting data structures, see~\cite{data_structure_spec}. For flow specifications, see~\cite{flow_spec}.

\section{TLS Connections and Allowed Cipher Suites}
Clients connect to the server via a TLS v1.2 connection. This restricts Android support to 4.2 and later.

For TLS v1.2, the server is configured to support the following cipher suites:

\begin{verbatim}
DHE-RSA-AES256-SHA
DHE-DSS-AES256-SHA
DHE-RSA-AES128-SHA
DHE-DSS-AES128-SHA
\end{verbatim}

\section{Random Number Generation}
\textbf{Details have to be completed later, once we know which crypto libraries are used for the implementation. A review will be required in any case.}

In general, when possible, we recommend directly using the output of \\/dev/urandom which is available on Android, Linux, and iOS. For Android, SecureRandom must be patched. Most 
if not all key generation of Android crypto library is based on SecureRandom. So, even if no direct call to SecureRandom is done on Android, this patch must be applied.

\subsection{Server}

\subsection{Android}

\subsection{iOS}

\subsection{Seeding}

\section{Authentication}
In this section we describe the authentication schemes employed between entities. We specify how the server authenticates to the clients and how a client authenticates to the 
server. By client we refer to both user and retailer clients. 

\subsection{Server to Client}
A client establishes a TLS connection to a preconfigured address. While negotiating the connection, the server sends its certificate to the client, which is used to authenticate 
the server to clients. Revocation lists need to be up to date. The certificate is issued by a major CA.

\subsection{Client to Server}
The first time a client connects to the server it generates a public/private key pair. The public key is sent to the server over the TLS connection. A signed registration code is 
sent as well to authenticate the user establishing the public key. See~\ref{sec:digital_signature} for technical specification of the client keys.

\section{ECDSA Digital Signature with SJCL}
\label{sec:digital_signature}

The Stanford Javascript Crypto Library implements digital signatures with ECDSA, which is the elliptic curve variant of DSA. Special caution should be taken with respect to the 
quality of the randomness used for signing in ECDSA. Namely, a single generated signature with predictable randomness can lead to disastrous consequences, e.g. complete leak of 
the private key.

\subsection{Randomness}
The implementation shall explicitly initialize the pseudo-random generator with 32 bytes (256 bit) read from \texttt{/dev/random} at the application load time. Note that 
\texttt{/dev/random} is available on both Android and iOS. If \texttt{/dev/random} leads to some performance issues, one can alternatively use its non-blocking variant 
\texttt{/dev/urandom}. Since it is done only once at load time, this should not be needed.

The method \texttt{sjcl.prng.addEntropy} for seeding shall be used with \texttt{data} being an array of 8 uint32 elements (initialized by \texttt{/dev/random}),\\ 
\texttt{estimatedEntropy} equals to 256, \texttt{source} being the string ``/dev/random''. The singleton \texttt{sjcl.random} shall be used and \texttt{defaultParanoia} is 
initialized with the value 6 which corresponds to the 256 bits entropy.

\subsection{Curve and Key Pair Generation}
The curve \texttt{c256} shall be used and the key pair is generated by calling\\\texttt{sjcl.ecc.ecdsa.generateKeys} with this curve as parameter and paranoia level 6.

\subsection{Signing}
The hash function \texttt{sjcl.hash.sha256} shall be used. This function is first called on the message to sign and the hash value is passed as first argument of 
\texttt{sjcl.ecc.ecdsa.secretKey.sign} with paranoia level 6.

\section{RSA-based Encryption}

\subsection{RSA-Based Cryptography}
We use RSA-based cryptography due to its homomorphic properties, necessary for the broadcast identity protocol, and its maturity and support on basically every platform compared 
to other cryptosystems with homomorphic properties. 

\subsection{Key Length}
RSA-based cryptography shall use key size of at least 2048 bits. This provides enough security for the next few years. However, the code should be easily configurable to 
accommodate upgrade of the key size.

\begin{itemize}
\item Hash Function: SHA-256
\item Salt size: 256 bits
\item Masking function: MGF1 with SHA-256
\item Trailer field: the number 1 corresponding to the hexadecimal value 0xBC (the default value of the standard)
\end{itemize}

These parameters should be easily upgraded in the code. For instance, it should be easy to migrate from SHA-256 to another hash function.

\bibliography{spec,crypto}
\bibliographystyle{plain}

\end{document}
