\documentclass[a4paper,10pt]{article}

\input{Common}

\newcommand{\signedData}{\emph{signedData}}
\newcommand{\encryptedData}{\emph{encryptedData}}
\newcommand{\newPublicKeys}{\emph{newPublicKeys}}
\newcommand{\newPrivateKeys}{\emph{newPrivateKeys}}
\newcommand{\code}{\emph{code}}
\newcommand{\serverVerified}{\emph{serverVerified}}
\newcommand{\handle}{\emph{handle}}
\newcommand{\personalData}{\emph{personalData}}
\newcommand{\registrationCode}{\emph{registrationCode}}
\newcommand{\userAgent}{\emph{userAgent}}
\newcommand{\privateKeys}{\emph{privateKeys}}
\newcommand{\publicKeys}{\emph{publicKeys}}
\newcommand{\signingKey}{\privateKeys{}.\emph{signing}}
\newcommand{\verificationKey}{\publicKeys{}.\emph{verification}}
\newcommand{\encryptionKey}{\publicKeys{}.\emph{encryption}}
\newcommand{\decryptionKey}{\privateKeys{}.\emph{decryption}}
\newcommand{\userId}{\emph{userId}}
\newcommand{\clientId}{\emph{clientId}}
\newcommand{\loggedIn}{\emph{loggedIn}}
\newcommand{\fixedString}{\emph{fixedString}}
\newcommand{\removeUser}{\emph{removeUser}}
\newcommand{\newHandle}{\emph{newHandle}}
\newcommand{\contactOperationSet}{\emph{contactOperationSet}}

\title{\longProduct{} System Flows and Protocols Specification}

\begin{document}

\maketitle
\tableofcontents

\section{Purpose}
This document specifies the protocols and flows executed for the \longProduct{} system (\shortProduct{}) between the \server{} and \client{} entities. The protocols cover contact 
management and administration flows (account creation, account deletion, etc).

\section{References}
For the project overview, see \cite{project_spec}. For the supporting data structures, see \cite{data_structure_spec}. For details about security and cryptography, 
see \cite{crypto_spec}. For the client UI elements specification, see \cite{UI_spec}.

\section{Definitions, Nomenclature and Conventions}

\subsection{Entities}
We refer to three entities in this document. These represent different participants in a flow. A short explanation on each one follows. For more detail on their role in the 
system, see \cite{project_spec}. Entities are denoted in all uppercase.

\begin{description}
 \item[\Server{}] includes the central business logic, the database and all interfaces to third-party systems for, among others, sending out notifications and mail.
 \item[\Client{}] is an abstraction of a user agent. It usually refers to the mobile app that a customer uses, but it can extend to desktop applications, test clients, etc.
 \item[\User{}] This is a special entity that refers to the human using \Client{}. It is used for flow steps that require interaction between the client user agent and the human 
user. This entity is not used for protocol specifications. It is used in flow specifications to disambiguate the origin and target of some steps.
\end{description}

\subsection{Notation for Variables}
\label{sec:variable_notation}
Because in each flow or protocol multiple participants are involved, variables are denoted with a hierarchical name, with each level denoted as a dot. For example, variable $X$ of 
entity $Y$ is denoted as $Y.X$. Inputs and outputs are considered variables.

Variables are declared as
\begin{center}
$\langle Entity\rangle.\langle Name\rangle:\langle type\rangle\{[qualification_1, qualification_2, \dots]\}$.
\end{center}

For example, let $bar$ be an unsigned integer variable of entity $foo$, that takes values in the range $[10,100]$ and has default value 5. The declaration would look like:

\begin{center}
 foo.bar:unsigned integer[range:[10,100],default value:5].
\end{center}

The qualifications part is optional and its syntax is that of a $key:value$ pair.

A data structure $D$ may appear without prior definition, when it has been specified in \cite{data_structure_spec}. For specifications of types related to security and 
cryptography, such as registration codes and elliptic curve keys, see \cite{crypto_spec}.

All variable names are small camelCase.

\subsection{Flow Specifications Organization and 
Format}\label{sec:flow_spec_def}
Each flow description is organized in the following sections:

\begin{description}
 \item[Description] What the flow does.
 \item[Participants] A list of participating entities.
 \item[Inputs] A list of the inputs to the flow. See \ref{sec:variable_notation} for the variable syntax.
 \item[Outputs] A list of the expected outputs to the flow. The syntax is the same as for inputs. Their description may be simplified when their meaning can be inferred from a 
more informal description.
 \item[Other variables] Any other variables that are instantiated during the flow.
 \item[Local definitions] Definitions of functions that are local to the flow. We provide in \ref{sec:definitions} some common global definitions, but there may be local functions 
that only make sense in the context of a flow.
 \item[Steps] An enumeration of the steps. The first word in each step is the initiating entity, meaning the entity that sends a message in this step.
\end{description}

\subsection{Protocol Specifications Organization and Format}

\subsection{Definitions}\label{sec:definitions}

\begin{description}
 \item[Public/Private Key] The public and private keys for entity $A$ are denoted as $K_{public}^A$ and $K_{private}^A$. The encryption of message $m$ for entity $A$ with key 
$K_{public}^A$ is denoted as $E(A,m)$. The decryption of encrypted message $d$ by entity $A$ with key $K_{private}^A$ is denoted as $D(A,d)$. The identity $m=D(A,E(A,m))$ holds.
 \item[Signature and Verification] The signing and verification keys for entity $A$ are denoted as $K_{sign}^A$ and $K_{verify}^A$. The signature of message $m$ by entity $A$ is 
denoted as $S(A,m)$. The verification of signature $s$ produced by $A$ is denoted as $V(A,s)$. The identity $m=V(A,S(A,m))$ holds.

Note that signing a message $m$ involves signing a hash of $m$ and accompanying the signature with $m$. This means that when \Client{} signs a message $m$ and sends the signature 
$s$ to \Server{}, \Server{} knows from $s$ the details of the message, like the client id, without having to decrypt $s$ first. See \cite{crypto_spec} for more details.
\end{description}

\subsection{Alternative Steps}
Some parts of the flow may have alternative specifications. These alternatives originate from usability concerns or uncertainty about hardware components, which may require 
multiple ways to effect the same action. Alternative steps are defined after the primary specification.

Alternative flow steps should be considered as future extensions. Initial implementation follows the primary flow specification, but it should take into account that alternative 
steps may replace the primary ones or that extensions of the implementation may incorporate multiple alternatives. Details about implementation priority and plans for these 
alternatives can be found in accompanying footnotes.

\section{Flows}

\subsection{Implicit Flow Branches}
Some flow branches are repeated and are followed under common triggers. To avoid cluttering the main flows, we define them here.

\subsubsection{Registration Code Verification}
When a step states that \Server{} checks the registration code, the following steps are implied:

\begin{enumerate}
 \item \Server{} checks the registration code in $RegistrationCodeMap$, with the key being \userId{} and \clientId{}.
 \begin{enumerate}
  \item If the checks succeeds, \Server{} removes the entry from\\$RegistrationCodeMap$.
  \item If the checks fails, \Server{} sends error to the entity that requested the check and terminates the flow.
 \end{enumerate}
\end{enumerate}

\subsubsection{Flow Termination with Error on Failed Commit}
Steps which state that entity $X$ commits $Y$ to the DB imply a flow branch that is followed when the commit operation fails. In this case, $X$ terminates the flow with an error. 
In most cases, error flows are inferable from other error branches. When this is not possible, the branch is declared explicitly. 

\subsubsection{Server Errors}
All flows involving \Server{} and another entity may fail for various reasons, such as \userId{} or \clientId{} being unknown or the signature verification failing. For security, 
\Server{} does not reveal the specific reason the operation failed. Therefore, when, for example, a registration code verification fails, the message from \Server{} to \Client{} 
does not differentiate between all the reasons the verification may fail.

\subsection{User Registration}

\paragraph{Description}
This protocol covers the flow where a user registers for the first time. The flow registers implicitly the client from which the registration took place.

\paragraph{Participants} \Server{}, \Client{}, \User{}

\paragraph{Inputs}
\SpecialItem
\begin{description}
 \item[\handle{}:$\langle$ Handle $\rangle$]
\end{description}

\paragraph{Outputs}
For \Client{} either success, if the user was registered successfully, or error if the user information is invalid or the user handle already exists.

\paragraph{Other Variables}
\SpecialItem
\begin{description}
 \item[\registrationCode{}:registration code]
 \item[\userAgent{}:UserAgent] This is produced by \Client{} and contains software and platform information.
 \item[\privateKeys{}:PrivateKeys] Generated by \Client{}.
 \item[\publicKeys{}:PublicKeys] Generated by \Client{}.
 \item[\userId{}:Id] The internal user id. We cannot use \handle{}, because it may change in the lifetime of an account. Generated by \Server{}.
 \item[\clientId{}:Id] The client id, generated by \Server{}.
 \item[\loggedIn{}:boolean] A flag indicating whether at \Client{} startup \Client{} transitions to the main screen or a log-in screen.
\end{description}

\paragraph{Flow}

\begin{enumerate}\label{user_registration_flow}
 \item\label{user_registration_flow:first} \Client{} requests \User{} to populate \handle{}.
 \item \User{} populates \handle{}.
 \item \Client{} stores \handle{} in secure local storage.
 \item \Client{} populates \userAgent{}, \publicKeys{} and \privateKeys{}{\userAgent{} is constructed at every client start, because the data may change due to OS or client 
upgrades.}.
 \item \Client{} stores \privateKeys{} to secure local storage\footnote.
 \item \Client{} sends \handle{}, \userAgent{} and \publicKeys{} to \Server{}.
 \item\label{user_registration_flow:fifth} \Server{} verifies the integrity of the received data and whether \handle{} is new to the system.
 \begin{enumerate}
  \item If the above step fails, \Server{} sends an error message to \Client{} and the flow terminates.
 \end{enumerate}
 \item\label{user_registration_flow:sixth} \Server{} generates \registrationCode{}, \userId{} and \clientId{}.
 \item\label{user_registration_flow:seventh} \Server{} commits \registrationCode{}, \userId{}, \clientId{}, \handle{}, \publicKeys{} and \userAgent{} to the DB.
 \item \Server{} sends \userId{} and \clientId{} to \Client{}.
 \item\label{user_registration_flow:second} \Client{} stores \userId{} and \clientId{} to secure local storage.
 \item \Client{} removes \handle{} from storage.
 \item \Server{} sends \registrationCode{} to \handle{}.
 \item\label{user_registration_flow:eighth} \User{} enters \registrationCode{} to \Client{}.
 \item\label{user_registration_flow:third} \Client{} sends \userId{}, \clientId{} and \registrationCode{} signed with \signingKey{} to \Server{}.
 \item \Server{} verifies that \registrationCode{} corresponds to \userId{} and \clientId{} to the DB and the signature is verified.
 \begin{enumerate}
  \item If the above check fails, \Server{} sends an error message to \Client{} and the flow terminates.
 \end{enumerate}
 \item\label{user_registration_flow:fourth} \Server{} marks $\langle$\userId{}, \clientId{}$\rangle$ as registered.
 \item \Client{} sets \loggedIn{} to true and stores it in secure storage.
\end{enumerate}

\subparagraph{Atomicity}
In the above flow there are two sections where if the connection between \Server{} and \Client{} fails, the whole section needs to repeated from the beginning. These sections are 
steps \ref{user_registration_flow:first}-\ref{user_registration_flow:second}, inclusive, and \ref{user_registration_flow:third}-\ref{user_registration_flow:fourth}, inclusive. In 
case of failure, \Server{} reverts any changes to the DB and \Client{} repeats the process with data that have been stored locally. For the first section \Client{} needs \handle{} 
and for the second \userId{} and \clientId{} from local storage and \registrationCode{} to be reentered by \User{}.

\subsection{Device Registration}

\paragraph{Description}
The device registration flow is similar to the user registration flow. The use case is a user that already exists wants to use their account on another device.

\paragraph{Participants} \Server{}, \Client{}, \User{}

\paragraph{Inputs}
\SpecialItem
\begin{description}
 \item[\handle{}:Handle]
\end{description}

\paragraph{Outputs}
For \Client{} either success, if the client was registered successfully, or error if the user information is invalid or the user handle doesn't already exists.

\paragraph{Other Variables}
\SpecialItem
\begin{description}
 \item[\registrationCode{}:registration code]
 \item[\userAgent{}:UserAgent] This is produced by \Client{} and contains software and platform information.
 \item[\privateKeys{}:PrivateKeys] Generated by \Client{}.
 \item[\publicKeys{}:PublicKeys] Generated by \Client{}.
 \item[\userId{}:Id] The internal user id. We cannot use \handle{}, because it may change in the lifetime of an account. Generated by \Server{}.
 \item[\clientId{}:Id] The client id, generated by the server.
\end{description}

\paragraph{Flow}

\begin{enumerate}\label{device_registration_flow}
 \item\label{device_registration_flow:first} \Client{} requests \User{} to populate \handle{}.
 \item \User{} populates \handle{}.
 \item \Client{} stores \handle{} in secure local storage.
 \item \Client{} populates \userAgent{}, \publicKeys{} and \privateKeys{}{\userAgent{} is constructed at every client start, because the data may change due to OS or client 
upgrades.}.
 \item \Client{} stores \privateKeys{} to secure local storage\footnote.
 \item \Client{} sends \handle{}, \userAgent{} and \publicKeys{} to \Server{}.
 \item\label{device_registration_flow:fifth} \Server{} verifies the integrity of the received data and whether \handle{} exists.
 \begin{enumerate}
  \item If the above step fails, \Server{} sends an error message to \Client{} and the flow terminates.
 \end{enumerate}
 \item\label{device_registration_flow:retrieve} \Server{} retrieves \userId{} from \handle{}.
 \item\label{device_registration_flow:sixth} \Server{} generates \registrationCode{} and \clientId{}.
 \item\label{device_registration_flow:seventh} \Server{} commits \registrationCode{}, \clientId{}, \handle{}, \publicKeys{} and \userAgent{} to the DB.
 \item \Server{} sends \userId{} and \clientId{} to \Client{}.
 \item\label{device_registration_flow:second} \Client{} stores \userId{} and \clientId{} to secure local storage.
 \item \Client{} removes \handle{} from storage.
 \item \Server{} sends \registrationCode{} to \handle{}.
 \item\label{device_registration_flow:eighth} \User{} enters \registrationCode{} to \Client{}.
 \item\label{device_registration_flow:third} \Client{} sends \userId{}, \clientId{} and \registrationCode{} signed with \signingKey{} to \Server{}.
 \item \Server{} verifies that \registrationCode{} corresponds to \userId{} and \clientId{} in its DB and the signature is verified.
 \begin{enumerate}
  \item If the above check fails, \Server{} sends an error message to \Client{} and the flow terminates.
 \end{enumerate}
 \item\label{device_registration_flow:fourth} \Server{} marks $\langle$\userId{}, \clientId{}$\rangle$ as registered.
 \item \Client{} sets \loggedIn{} to true and stores it in secure storage.
 \item \Client{} displays to \User{} that registration succeeded.
\end{enumerate}

\subparagraph{Atomicity}
In the above flow there are two sections where if the connection between \Server{} and \Client{} fails, the whole section needs to repeated from the beginning. These sections are 
steps \ref{device_registration_flow:first}-\ref{device_registration_flow:second}, inclusive, and \ref{device_registration_flow:third}-\ref{device_registration_flow:fourth}, 
inclusive. In case of failure, \Server{} reverts any changes to the DB and \Client{} repeats the process with data that have been stored locally. For the first section \Client{} 
needs \handle{} and for the second \userId{} and \clientId{} from local storage and \registrationCode{} to be reentered by \User{}.

\paragraph{Implementation Notes}
User and device registration flows are almost identical. The differences are:

\begin{itemize}
 \item In step \ref{user_registration_flow}.\ref{user_registration_flow:fifth}, the check for is whether \handle{} does not exist. In step 
\ref{device_registration_flow}.\ref{device_registration_flow:fifth}, the check is whether \handle{} exists. This check can be implemented as a pure virtual method in the base 
class and the two flows can share the flow code.
 \item In step \ref{user_registration_flow}.\ref{user_registration_flow:sixth} \userId{} is generated, which doesn't happen in step 
\ref{device_registration_flow}.\ref{device_registration_flow:sixth}. Similarly, in step \ref{user_registration_flow}.\ref{user_registration_flow:seventh} \Server{}
creates a new user and adds a client to its list, while in step \ref{device_registration_flow}.\ref{device_registration_flow:seventh} \Server{} adds a client to the user retrieved 
in step \ref{device_registration_flow}.\ref{device_registration_flow:retrieve}. The different actions can be plugged in a common flow code.
 \item From the perspective of \Client{}, the steps after \ref{user_registration_flow}.\ref{user_registration_flow:eighth} and 
\ref{device_registration_flow}.\ref{device_registration_flow:eighth} are identical and can be implemented as the same UI flow.
\end{itemize}

\subsection{Modify Keys}
\label{modify_keys_flow}
This flow is triggered periodically from the client. For details about when it is triggered see \cite{crypto_spec}.

\paragraph{Participants} \Client{}, \Server{}

\paragraph{Inputs}
\SpecialItem
\begin{description}
 \item[\userId{}:Id] From \Client{} local storage.
 \item[\clientId{}:Id] From \Client{} local storage.
 \item[\privateKeys{}:PrivateKeys] The private keys that are valid at the start of the flow. From \Client{} local storage.
\end{description}

\paragraph{Outputs}
For \Client{} either success, if \Server{} applied the changes, error otherwise. In case of error, the new keys are discarded and the flow is repeated according to the 
specification in \cite{crypto_spec}.

\paragraph{Other Variables}
\SpecialItem
\begin{description}
 \item[\newPrivateKeys{}:PrivateKeys] The new private keys.
 \item[\newPublicKeys{}:PublicKeys] The new public keys.
 \item[\signedData{}:ECDSA signature] The ECDSA signature of \newPublicKeys{} with \signingKey{}. See \cite{crypto_spec} for details.
 \item[\publicKeys{}:PublicKeys] The public keys of \Client{} stored in the DB of \Server{}.
\end{description}

\paragraph{Flow}

\begin{enumerate}
 \item \Client{} constructs \newPrivateKeys{}, \newPublicKeys{}.
 \item \Client{} generates \signedData{}.
 \item \Client{} sends \signedData{}, \newPublicKeys{}, \userId{} and \clientId{} to \Server{}.
 \item \Server{} retrieves \publicKeys{} based on \userId{} and \clientId{}.
 \item \Server{} verifies the signature of \signedData{}.
 \begin{enumerate}
  \item If the above step fails, \Server{} replies with error.
 \end{enumerate}
 \item \Server{} verifies the integrity of \newPublicKeys{}.
 \begin{enumerate}
  \item If the above step fails, \Server{} replies with error.
 \end{enumerate}
 \item \Server{} commits \newPublicKeys{} to the DB.
 \item \Server{} replies with success.
 \item\label{modify_keys_flow:local_storage} \Client{} commits \newPrivateKeys{} to secure local storage.
\end{enumerate}

\subsection{Modify User Agent}
\label{modify_user_agent_flow}
This flow is triggered when the user agent has changed, due to client or OS updates. The flow is identical to \ref{modify_keys_flow}, with the difference that \signedData{} 
signs the new user agent, instead of \newPublicKeys{}. The implementation must be common, parameterized for the input data.

This flow does not require a registration code, as the effects are reversible and the \handle{} information does not change.

\subsection{Delete Client}
This flow deletes client information from the server and logs out the client. 
When the last client is deleted for a user, the user information is deleted 
from the server as well.

\paragraph{Participants} \Client{}, \Server{}, \User{}

\paragraph{Inputs}
\SpecialItem
\begin{description}
 \item[\userId{}:Id] From \Client{} local storage.
 \item[\clientId{}:Id] From \Client{} local storage.
\end{description}

\paragraph{Outputs}
For \Client{} either success, if \Server{} deleted \Client{} successfully, 
error otherwise. If the flow failed, \Client{} stays active.

\paragraph{Other Variables}
\SpecialItem
\begin{description}
 \item[\publicKeys{}:PublicKeys] The public keys of  \Client{}. 
 \item[\privateKeys{}:PrivateKeys] Theprivate keys of \Client{}.
 \item[\registrationCode{}:registration code]
 \item[\signedData{}:ECDSA signature] \registrationCode{} signed with
\privateKeys{}. See \cite{crypto_spec} for details.
 \item[\handle{}:Handle]
 \item[\removeUser:boolean] Whether the user account is to be removed.
\end{description}

\paragraph{Flow}

\begin{enumerate}
 \item \User{} requests \Client{} be deleted.
 \item \Client{} sends \userId{} and \clientId{} to \Server{}.
 \item \Server{} retrieves \handle{} from its DB based on \userId{} and 
\clientId{}.
 \item \Server{} generates \registrationCode{}.
 \item \Server{} sends \registrationCode{} to \handle{}.
 \item \User{} enters \handle{} to \Client{}.
 \item \Client{} generates \signedData{} from \registrationCode{}, 
\privateKeys{}.
 \item \Client{} sends \signedData{}, \userId{}, \clientId{} to \Server{}.
 \item \Server{} retrieves \publicKeys{} from its DB based on \userId{} and 
\clientId{}.
 \item \Server{} verifies \registrationCode{} based on its DB and \publicKeys{}.
 \begin{enumerate}
  \item If the above step failed, \Server{} sends error to \Client{}.
  \item \Client{} terminates the flow.
 \end{enumerate}
 \item \Server{} checks if \clientId{} is that last entry in $UserSet.clients$.
 \begin{enumerate}
  \item If it is not, \Server{} sets \removeUser{} and goes to 
step \ref{delete_client:first}.
  \item If it is, \Server{} sends to \Client{} a request to remove the entire 
user account.
  \item \Client{} asks \User{} about whether the account can be removed.
  \item \User{} answers the query.
  \item \Client{} sets the value of \removeUser{} according to the answer by 
\User{}.
  \item{} \Client{} sends \removeUser{}, \userId{} and \clientId{} to 
\Server{}, signed with \privateKeys{}.
  \item{} \Server{} verifies the signature of \removeUser{} and sets the value 
of \removeUser{}.
  \begin{enumerate}
   \item If the signature verification fails, \Server{} sends \Client{} an 
error.
   \item \Client{} terminates the flow with error.
  \end{enumerate}
 \end{enumerate}
 \item\label{delete_client:first} \Server{} removes from $UserSet.clients$ the 
entry for \clientId{}.
 \item If \removeUser{} is true, \Server{} removes \userId{} from $UserSet$.
 \item \Server{} sends success to \Client{}.
 \item \Client{} removes \clientId{} and \privateKeys{} from its DB.
 \item \Client{} sets \loggedIn{} to false and commits it to local storage.
\end{enumerate}

\subsection{Update Server Contact Book}
This flow updates the contact book that is stored server-side.

\paragraph{Participants} \Client{}, \Server{}

\paragraph{Inputs}
\SpecialItem
\begin{description}
 \item[\userId{}:Id] From \Client{} local storage.
 \item[\clientId{}:Id] From \Client{} local storage.
 \item[\contactOperationSet{}: ContactOperationSet] Generated by \Client{}.
\end{description}

\paragraph{Outputs}
For \Client{} either success, if \Server{} updated all contacts successfully, failure if something went wrong during the update. In case of failure the entire set is rejected.

\paragraph{Other Variables}
\SpecialItem
\begin{description}
 \item[\publicKeys{}:PublicKeys] The public keys of  \Client{}. 
 \item[\privateKeys{}:PrivateKeys] Theprivate keys of \Client{}.
 \item[\signedData{}:ECDSA signature] \contactOperationSet{} signed with
\privateKeys{}. See \cite{crypto_spec} for details.
\end{description}

\paragraph{Flow}

\begin{enumerate}
 \item \Client{} generates \contactOperationSet{}.
 \item \Client{} generates \signedData{} from \contactOperationSet{} and \privateKeys{}.
 \item \Client{} sends \contactOperationSet{}, \signedData{}, \userId{} and \clientId{} to \Server{}.
 \item \Server{} retrieves \publicKeys{} from its DB based on \userId{} and 
\clientId{}.
 \item \Server{} verifies \signedData{} based on \contactOperationSet{} and \publicKeys{}.
 \begin{enumerate}
  \item If the above step failed, \Server{} sends error to \Client{}.
  \item \Client{} terminates the flow.
 \end{enumerate}
 \item For each entry $A$ in \contactOperationSet{}
 \begin{enumerate}
  \item If the operation is {\em Add} \Server{} updates the graph and generates the appropriate notifications to \Client{}.
  \item If the operation is {\em Delete} \Server{} updates the graph.
 \end{enumerate}
\end{enumerate}

\bibliography{spec}
\bibliographystyle{plain}

\end{document}
