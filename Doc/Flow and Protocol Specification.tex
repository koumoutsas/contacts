\documentclass[a4paper,10pt]{article}

\input{Common}

\newcommand{\signedData}{\emph{signedData}}
\newcommand{\encryptedData}{\emph{encryptedData}}
\newcommand{\newPublicKeys}{\emph{newPublicKeys}}
\newcommand{\newPrivateKeys}{\emph{newPrivateKeys}}
\newcommand{\code}{\emph{code}} 
\newcommand{\serverVerified}{\emph{serverVerified}}
\newcommand{\personalData}{\emph{personalData}}
\newcommand{\registrationCode}{\emph{registrationCode}}
\newcommand{\userAgent}{\emph{userAgent}}
\newcommand{\privateKeys}{\emph{privateKeys}}
\newcommand{\publicKeys}{\emph{publicKeys}}
\newcommand{\signingKey}{\privateKeys{}.\emph{signing}}
\newcommand{\verificationKey}{\publicKeys{}.\emph{verification}}
\newcommand{\encryptionKey}{\publicKeys{}.\emph{encryption}}
\newcommand{\decryptionKey}{\privateKeys{}.\emph{decryption}}
\newcommand{\userId}{\emph{userId}}
\newcommand{\clientId}{\emph{clientId}}
\newcommand{\loggedIn}{\emph{loggedIn}}
\newcommand{\fixedString}{\emph{fixedString}}
\newcommand{\removeUser}{\emph{removeUser}}
\newcommand{\contactOperationSet}{\emph{contactOperationSet}}
\newcommand{\identity}[1]{{\em identity(#1)}}
\newcommand{\link}[1]{{\em link(#1)}}

\title{\longProduct{} System Flows and Protocols Specification}

\begin{document}

\maketitle
\tableofcontents

\section{Purpose}
This document specifies the protocols and flows executed for the \longProduct{} system (\shortProduct{}) between the \server{} and \client{} entities. The protocols cover contact 
management and administration flows (account creation, account deletion, etc).

\section{References}
For the project overview, see \cite{project_spec}. For the supporting data structures, see \cite{data_structure_spec}. For details about security and cryptography, 
see \cite{crypto_spec}. For the client UI elements specification, see \cite{UI_spec}.

\section{Definitions, Nomenclature and Conventions}

\subsection{Entities}
We refer to three entities in this document. These represent different participants in a flow. A short explanation on each one follows. For more detail on their role in the 
system, see \cite{project_spec}. Entities are denoted in all uppercase.

\begin{description}
 \item[\Server{}] includes the central business logic, the database and all interfaces to third-party systems for, among others, sending out notifications and mail.
 \item[\Client{}] is an abstraction of a user agent. It usually refers to the mobile app that a customer uses, but it can extend to desktop applications, test clients, etc. When 
more than one \client{} entities participate in a flow, let's say on behalf of users $A$ and $B$, they are denoted as \client[A] and \client[B].
 \item[\User{}] This is an entity that refers to the human using \Client{}. It is used for flow steps that require interaction between the client user agent and the human user. 
This entity is not used for protocol specifications. It is used in flow specifications to disambiguate the origin and target of some steps. When more than one \user{} entities 
participate in the flow, corresponding to let's say human users $A$ and $B$, they are denoted as \user[A] and \user[B].
\end{description}

\subsection{Notation for Variables}
\label{sec:variable_notation}
Because in each flow or protocol multiple participants are involved, variables are denoted with a hierarchical name, with each level denoted as a dot. For example, variable $X$ of 
entity $Y$ is denoted as $Y.X$. Inputs and outputs are considered variables.

Variables are declared as
\begin{center}
$\langle Entity\rangle.\langle Name\rangle:\langle type\rangle\{[qualification_1, qualification_2, \dots]\}$.
\end{center}

For example, let $bar$ be an unsigned integer variable of entity $foo$, that takes values in the range $[10,100]$ and has default value 5. The declaration would look like:

\begin{center}
 foo.bar:unsigned integer[range:[10,100],default value:5].
\end{center}

The qualifications part is optional and its syntax is that of a $key:value$ pair.

A data structure $D$ may appear without prior definition, when it has been specified in \cite{data_structure_spec}. For specifications of types related to security and 
cryptography, such as registration codes and elliptic curve keys, see \cite{crypto_spec}.

All variable names are small camelCase.

\subsection{Flow Specifications Organization and Format}\label{sec:flow_spec_def}
Each flow description is organized in the following sections:

\begin{description}
 \item[Description] What the flow does.
 \item[Participants] A list of participating entities.
 \item[Inputs] A list of the inputs to the flow. See \ref{sec:variable_notation} for the variable syntax.
 \item[Outputs] A list of the expected outputs to the flow. The syntax is the same as for inputs. Their description may be simplified when their meaning can be inferred from a 
more informal description.
 \item[Other variables] Any other variables that are instantiated during the flow.
 \item[Local definitions] Definitions of functions that are local to the flow. We provide in \ref{sec:definitions} some common global definitions, but there may be local functions 
that only make sense in the context of a flow.
 \item[Steps] An enumeration of the steps. The first word in each step is the initiating entity, meaning the entity that sends a message in this step.
\end{description}

\subsection{Protocol Specifications Organization and Format}

\subsection{Definitions}\label{sec:definitions}

\begin{description}
 \item[Public/Private Key] The public and private keys for entity $A$ are denoted as $K_{public}^A$ and $K_{private}^A$. The encryption of message $m$ for entity $A$ with key 
$K_{public}^A$ is denoted as $E(A,m)$. The decryption of encrypted message $d$ by entity $A$ with key $K_{private}^A$ is denoted as $D(A,d)$. The identity $m=D(A,E(A,m))$ holds.
 \item[Signature and Verification] The signing and verification keys for entity $A$ are denoted as $K_{sign}^A$ and $K_{verify}^A$. The signature of message $m$ by entity $A$ is 
denoted as $S(A,m)$. The verification of signature $s$ produced by $A$ is denoted as $V(A,s)$. The identity $m=V(A,S(A,m))$ holds.

Note that signing a message $m$ involves signing a hash of $m$ and accompanying the signature with $m$. This means that when \Client{} signs a message $m$ and sends the signature 
$s$ to \Server{}, \Server{} knows from $s$ the details of the message, like the client id, without having to decrypt $s$ first. See \cite{crypto_spec} for more details.
\end{description}

\subsection{Alternative Steps}
Some parts of the flow may have alternative specifications. These alternatives originate from usability concerns or uncertainty about hardware components, which may require 
multiple ways to effect the same action. Alternative steps are defined after the primary specification.

Alternative flow steps should be considered as future extensions. Initial implementation follows the primary flow specification, but it should take into account that alternative 
steps may replace the primary ones or that extensions of the implementation may incorporate multiple alternatives. Details about implementation priority and plans for these 
alternatives can be found in accompanying footnotes.

\section{Flows}

\subsection{Implicit Flow Branches}
Some flow branches are repeated and are followed under common triggers. To avoid cluttering the main flows, we define them here.

\subsubsection{Flow Termination with Error on Failed Commit}
Steps which state that entity $X$ commits $Y$ to the DB imply a flow branch that is followed when the commit operation fails. In this case, $X$ terminates the flow with an error. 
In most cases, error flows are inferable from other error branches. When this is not possible, the branch is declared explicitly. 

\subsubsection{Server Errors}
All flows involving \Server{} and another entity may fail for various reasons, such as \userId{} or \clientId{} being unknown or the signature verification failing. For security, 
\Server{} does not reveal the specific reason the operation failed. Therefore, when, for example, a registration code verification fails, the message from \Server{} to \Client{} 
does not differentiate between all the reasons the verification may fail.

\subsection{Identity Registration}
\label{identity_registration_flow}
This flow is followed when a user $A$ wants to enter the system. This is done by requesting a user $B$ who is already in the system to confirm $A$'s identity.

\paragraph{Participants} \User[A], \User[B], \Client[A], \Client[B], \Server{}

\paragraph{Inputs}
\SpecialItem
\begin{description}
 \item[\identity{A}:Client.Identity] From \Client[A]. This may come from the contact book of \User[A] or by \User[A] manually entering the value.
 \item[\identity{B}:Client.Identity] From the contact book of \User[A].
\end{description}

\paragraph{Outputs}
For \Client[A] either success, if \Server{} accepts the registration, error otherwise. In case of error, \User[A] is notified. \Client[B] removes the temporary mappings for 
\identity{A} after a certain period without confirmation from \Server{} has passed.

\paragraph{Other Variables}
\SpecialItem
\begin{description}
 \item[\link{A}:RegistrationLink] A registration link constructed by \Client[B] and sent to \User[A].
 \item[\link{B}:InvitationRequestLink] An invitation request link constructed by \Client[A] and sent to \User[B].
 \item[$N(A)$:RandomHashPad] A random blind for \identity{A}.
 \item[$U(A)$:HashBuffer] The blinded \identity{A} generated by \Client[B].
 \item[$U_{id}(A)$:Server.IdentityId] A pair of user id and identity id for \identity{A} generated by \Server{}.
 \item[$N_S(A)$:RandomHashPad] A random blind for \identity{A} generated by \Server{}.
 \item[$X(A)$:RandomHashPad] The XOR of two random blinds.
 \item[\privateKeys{}:PrivateKeys] The new private keys for \Client[A].
 \item[\publicKeys{}:PublicKeys] The new public keys for \Client[B].
 \item[$N_C(A)$:RandomHashPad] A random blind for \identity{A} generated by \Client[A].
 \item[\signedData{}:ECDSA signature] The ECDSA signature with \signingKey{} of \Client[A] registration data. See \cite{crypto_spec} for details.
\end{description}

\paragraph{Flow}

\begin{enumerate}
 \item \User[A] requests \Client[A] to notify \User[B].
 \item \Client[A] constructs \link{B} from \identity{A}.
 \item \Client[A] sends \link{B} to \identity{B}.
 \item \User[B] clicks on \link{B} and the flow passes to \Client[B]. If \User[B] doesn't react in this step, the flow terminates.
 \item \Client[B] extracts \identity{A} from \link{B}.
 \item If \Client[B] knows \identity{A} already, it populates $U(A)$ from its local storage and it goes to step~\ref{identity_registration_flow:send_hash}.
 \item \Client[B] generates $N(A)$.
 \item \Client[B] stores locally the triplet $\langle$\identity{A}$,U(A),N(A)$ to the PendingIdentitiesSet.
 \item \Client[B] calculates $U(A)=Hash($\identity{A}$,N(A))$.
 \item \Client[B] stores $U(A)$ as a HashBuffer mapped to \identity{A} in UnconfirmedIdentities.
 \item\label{identity_registration_flow:send_hash} \Client[B] sends to \Server{} request for registering $U(A)$.
 \item \Server{} checks in HashIdentityMap if there is a mapping for $U(A)$.
 \begin{enumerate}
  \item If there is, it populates $U_id(A)$ with the value of the mapping.
  \item If there isn't, it generates a new $U_{id}{A}$ and creates a mapping from $U(A)$ to $U_{id}(A)$ in HashIdentityMap. It creates an entry in UserMap with $U_{id}(A).userId$ 
and adds to it the mapping $U_{id}(A).identityId:U(A)$.
 \end{enumerate}
 \item \Server{} adds \Client[B] to the list of confirmers of $U_{id}(A).identityId$ in UserMap.
 \item \Server{} populates $N_S(A)$ and adds it to the mapping for $U_{id}(A)$ in UserMap.
 \item \Server{} sends to \Client[B] $U_{id}(A)$ and $N_S(A)$.
 \item \Client[B] calculates $X(A)=N(A)\oplus N_S(A)$.
 \item \Client[B] generates \link{A} from $U_{id}(A)$ and $X(A)$.
 \item \Client[B] sends \link{A} to \identity{A}.
 \item \Client[A] retrieves $U_{id}(A)$ and $X(A)$ from \link{A}.
 \item \Client[A] sends to \Server{} $U_{id}(A)$.
 \item \Server{} retrieves $N_S(A)$ from UserMap and key $U_{id}(A)$.
 \begin{enumerate}
  \item If the retrieval fails, \Server{} sends failure to \Client[A] and terminates the flow.
 \end{enumerate}
 \item \Server{} sends $N_S(A)$ to \Client[A].
 \item \Client[A] calculates $N(A)=N_S(A)\oplus X(A)$.
 \item \Client[A] calculates $U(A)=Hash($\identity{A}$,N(A)\oplus N(A)$.
 \item \Client[A] populates $N_C(A)$, \privateKeys{} and \publicKeys{}.
 \item \Client[A] stores $N_C(A)$ to local storage.
 \item For every identitiy $i$ that \Client[A] wants to register with \Server{}, including \identity{A}, it generates $U_i(A)=Hash(i,N_C(A)$.
 \item \Client[A] populates \signedData{} from \signingKey{} and \identity{B},\publicKeys{},$U(A),U_{id}(A),\lbrace U_1(A),\ldots,U_i(A),\ldots\rbrace,j$, where $j$ is the index 
for \identity{A}.
 \item \Server{} verifies the signature and that $U(A)$ maps to $U_{id}(A)$ in HashIdentityMap.
 \begin{enumerate}
  \item If the verification fails, \Server{} sends failure to \Client[A] and terminates the flow.
 \end{enumerate}
 \item \Server{} registers $\lbrace U_1(A),\ldots,U_i(A),\ldots\rbrace$ for $U_{id}(A)$ in HashIdentityMap and UserMap.
 \item \Server{} removes $U(A)$ from UserMap and adds it as alias in UserMap for $U_j(A)$. It merges the confirmer sets for the two.
 \item \Server{} replies with success to \Client[A].
 \item \Server{} sends to \Client[B] confirmation that $U(A)$ is confirmed.
 \item \Client[B] executes the Send Contact Card flow with \Client[A].
 \item \Client[B] removes from UnconfirmedIdentities $U(A)$ and adds \identity{A} to the \longProduct{} contact book.
 \item \Client[B] executes the identity broadcast protocol for \identity{A}.
\end{enumerate}

\subsection{Modify Keys}
\label{modify_keys_flow}
This flow is triggered periodically from the client. For details about when it is triggered see \cite{crypto_spec}.

\paragraph{Participants} \Client{}, \Server{}

\paragraph{Inputs}
\SpecialItem
\begin{description}
 \item[\userId{}:Id] From \Client{} local storage.
 \item[\clientId{}:Id] From \Client{} local storage.
 \item[\privateKeys{}:PrivateKeys] The private keys that are valid at the start of the flow. From \Client{} local storage.
\end{description}

\paragraph{Outputs}
For \Client{} either success, if \Server{} applied the changes, error otherwise. In case of error, the new keys are discarded and the flow is repeated according to the 
specification in \cite{crypto_spec}.

\paragraph{Other Variables}
\SpecialItem
\begin{description}
 \item[\newPrivateKeys{}:PrivateKeys] The new private keys.
 \item[\newPublicKeys{}:PublicKeys] The new public keys.
 \item[\signedData{}:ECDSA signature] The ECDSA signature of \newPublicKeys{} with \signingKey{}. See \cite{crypto_spec} for details.
 \item[\publicKeys{}:PublicKeys] The public keys of \Client{} stored in the DB of \Server{}.
\end{description}

\paragraph{Flow}

\begin{enumerate}
 \item \Client{} constructs \newPrivateKeys{}, \newPublicKeys{}.
 \item \Client{} generates \signedData{}.
 \item \Client{} sends \signedData{}, \newPublicKeys{}, \userId{} and \clientId{} to \Server{}.
 \item \Server{} retrieves \publicKeys{} based on \userId{} and \clientId{}.
 \item \Server{} verifies the signature of \signedData{}.
 \begin{enumerate}
  \item If the above step fails, \Server{} replies with error.
 \end{enumerate}
 \item \Server{} verifies the integrity of \newPublicKeys{}.
 \begin{enumerate}
  \item If the above step fails, \Server{} replies with error.
 \end{enumerate}
 \item \Server{} commits \newPublicKeys{} to the DB.
 \item \Server{} replies with success.
 \item\label{modify_keys_flow:local_storage} \Client{} commits \newPrivateKeys{} to secure local storage.
\end{enumerate}

\subsection{Modify User Agent}
\label{modify_user_agent_flow}
This flow is triggered when the user agent has changed, due to client or OS updates. The flow is identical to \ref{modify_keys_flow}, with the difference that \signedData{} 
signs the new user agent, instead of \newPublicKeys{}. The implementation must be common, parameterized for the input data.

\subsection{Update Server Contact Book}
This flow updates the contact book that is stored server-side.

\paragraph{Participants} \Client{}, \Server{}

\paragraph{Inputs}
\SpecialItem
\begin{description}
 \item[\userId{}:Id] From \Client{} local storage.
 \item[\clientId{}:Id] From \Client{} local storage.
 \item[\contactOperationSet{}: ContactOperationSet] Generated by \Client{}.
\end{description}

\paragraph{Outputs}
For \Client{} either success, if \Server{} updated all contacts successfully, failure if something went wrong during the update. In case of failure the entire set is rejected.

\paragraph{Other Variables}
\SpecialItem
\begin{description}
 \item[\publicKeys{}:PublicKeys] The public keys of  \Client{}. 
 \item[\privateKeys{}:PrivateKeys] Theprivate keys of \Client{}.
 \item[\signedData{}:ECDSA signature] \contactOperationSet{} signed with
\privateKeys{}. See \cite{crypto_spec} for details.
\end{description}

\paragraph{Flow}

\begin{enumerate}
 \item \Client{} generates \contactOperationSet{}.
 \item \Client{} generates \signedData{} from \contactOperationSet{} and \privateKeys{}.
 \item \Client{} sends \contactOperationSet{}, \signedData{}, \userId{} and \clientId{} to \Server{}.
 \item \Server{} retrieves \publicKeys{} from its DB based on \userId{} and 
\clientId{}.
 \item \Server{} verifies \signedData{} based on \contactOperationSet{} and \publicKeys{}.
 \begin{enumerate}
  \item If the above step failed, \Server{} sends error to \Client{}.
  \item \Client{} terminates the flow.
 \end{enumerate}
 \item For each entry $A$ in \contactOperationSet{}
 \begin{enumerate}
  \item If the operation is {\em Add} \Server{} updates the graph and generates the appropriate notifications to \Client{}.
  \item If the operation is {\em Delete} \Server{} updates the graph.
 \end{enumerate}
\end{enumerate}

\bibliography{spec}
\bibliographystyle{plain}

\end{document}
