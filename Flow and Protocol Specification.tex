\documentclass[a4paper,10pt,draft]{article}

\input{Common}

\newcommand{\signedData}{\emph{signedData}}
\newcommand{\encryptedData}{\emph{encryptedData}}
\newcommand{\newPublicKeys}{\emph{newPublicKeys}}
\newcommand{\newPrivateKeys}{\emph{newPrivateKeys}}
\newcommand{\code}{\emph{code}}
\newcommand{\serverVerified}{\emph{serverVerified}}
\newcommand{\handle}{\emph{handle}}
\newcommand{\personalData}{\emph{personalData}}
\newcommand{\registrationCode}{\emph{registrationCode}}
\newcommand{\userAgent}{\emph{userAgent}}
\newcommand{\privateKeys}{\emph{privateKeys}}
\newcommand{\publicKeys}{\emph{publicKeys}}
\newcommand{\signingKey}{\privateKeys{}.\emph{signing}}
\newcommand{\verificationKey}{\publicKeys{}.\emph{verification}}
\newcommand{\encryptionKey}{\publicKeys{}.\emph{encryption}}
\newcommand{\decryptionKey}{\privateKeys{}.\emph{decryption}}
\newcommand{\userId}{\emph{userId}}
\newcommand{\clientId}{\emph{clientId}}
\newcommand{\loggedIn}{\emph{loggedIn}}
\newcommand{\fixedString}{\emph{fixedString}}
\newcommand{\removeUser}{\emph{removeUser}}
\newcommand{\newHandle}{\emph{newHandle}}

\title{\longProduct{} System Flows and Protocols Specification}

\begin{document}

\maketitle
\tableofcontents

\section{Purpose}
This document specifies the protocols and flows executed for the \longProduct{} system (\shortProduct{}) between the \server{} and \client{} entities. The protocols cover contact 
management and administration flows (account creation, account deletion, etc).

\section{References}
For the project overview, see \cite{project_spec}. For the supporting data structures, see \cite{data_structure_spec}. For details about security and cryptography, 
see \cite{crypto_spec}. For the client UI elements specification, see \cite{UI_spec}.

\section{Definitions, Nomenclature and Conventions}

\subsection{Entities}
We refer to three entities in this document. These represent different participants in a flow. A short explanation on each one follows. For more detail on their role in the 
system, see \cite{project_spec}. Entities are denoted in all uppercase.

\begin{description}
 \item[\Server{}] includes the central business logic, the database and all interfaces to third-party systems for, among others, sending out notifications and mail.
 \item[\Client{}] is an abstraction of a user agent. It usually refers to the mobile app that a customer uses, but it can extend to desktop applications, test clients, etc.
 \item[\User{}] This is a special entity that refers to the human using \Client{}. It is used for flow steps that require interaction between the client user agent and the human 
user. This entity is not used for protocol specifications. It is used in flow specifications to disambiguate the origin and target of some steps.
\end{description}

\subsection{Notation for Variables}
\label{sec:variable_notation}
Because in each flow or protocol multiple participants are involved, variables are denoted with a hierarchical name, with each level denoted as a dot. For example, variable $X$ of 
entity $Y$ is denoted as $Y.X$. Inputs and outputs are considered variables.

Variables are declared as
\begin{center}
$\langle Entity\rangle.\langle Name\rangle:\langle type\rangle\{[qualification_1, qualification_2, \dots]\}$.
\end{center}

For example, let $bar$ be an unsigned integer variable of entity $foo$, that takes values in the range $[10,100]$ and has default value 5. The declaration would look like:

\begin{center}
 foo.bar:unsigned integer[range:[10,100],default value:5].
\end{center}

The qualifications parts is optional and its syntax is that of a $key:value$ pair.

A data structure $D$ may appear without prior definition, when it has been specified in \cite{data_structure_spec}. For specifications of types related to security and 
cryptography, such as registration codes and elliptic curve keys, see \cite{crypto_spec}.

All variable names are small camelCase.

\subsection{Flow Specifications Organization and 
Format}\label{sec:flow_spec_def}
Each flow description is organized in the following sections:

\begin{description}
 \item[Description] What the flow does.
 \item[Participants] A list of participating entities.
 \item[Inputs] A list of the inputs to the flow. See \ref{sec:variable_notation} for the variable syntax.
 \item[Outputs] A list of the expected outputs to the flow. The syntax is the same as for inputs. Their description may be simplified when their meaning can be inferred from a 
more informal description.
 \item[Other variables] Any other variables that are instantiated during the flow.
 \item[Local definitions] Definitions of functions that are local to the flow. We provide in \ref{sec:definitions} some common global definitions, but there may be local functions 
that only make sense in the context of a flow.
 \item[Steps] An enumeration of the steps. The first word in each step is the initiating entity, meaning the entity that sends a message in this step.
\end{description}

\subsection{Protocol Specifications Organization and Format}

\subsection{Definitions}\label{sec:definitions}

\begin{description}
 \item[Public/Private Key] The public and private keys for entity $A$ are denoted as $K_{public}^A$ and $K_{private}^A$. The encryption of message $m$ for entity $A$ with key 
$K_{public}^A$ is denoted as $E(A,m)$. The decryption of encrypted message $d$ by entity $A$ with key $K_{private}^A$ is denoted as $D(A,d)$. The identity $m=D(A,E(A,m))$ holds.
 \item[Signature and Verification] The signing and verification keys for entity $A$ are denoted as $K_{sign}^A$ and $K_{verify}^A$. The signature of message $m$ by entity $A$ is 
denoted as $S(A,m)$. The verification of signature $s$ produced by $A$ is denoted as $V(A,s)$. The identity $m=V(A,S(A,m))$ holds.

Note that signing a message $m$ involves signing a hash of $m$ and accompanying the signature with $m$. This means that when \Client{} signs a message $m$ and sends the signature 
$s$ to \Server{}, \Server{} knows from $s$ the details of the message, like the client id, without having to decrypt $s$ first. See \cite{crypto_spec} for more details.
\end{description}

\subsection{Alternative Steps}
Some parts of the flow may have alternative specifications. These alternatives originate from usability concerns or uncertainty about hardware components, which may require 
multiple ways to effect the same action. Alternative steps are defined after the primary specification.

Alternative flow steps should be considered as future extensions. Initial implementation follows the primary flow specification, but it should take into account that alternative 
steps may replace the primary ones or that extensions of the implementation may incorporate multiple alternatives. Details about implementation priority and plans for these 
alternatives can be found in accompanying footnotes.

\section{Flows}

\subsection{Implicit Flow Branches}
Some flow branches are repeated and are followed under common triggers. To avoid cluttering the main flows, we define them here.

\subsubsection{Registration Code Verification}
When a step states that \Server{} checks the registration code, the following steps are implied:

\begin{enumerate}
 \item \Server{} checks the registration code in $RegistrationCodeMap$, with the key being \userId{} and \clientId{}.
 \begin{enumerate}
  \item If the checks succeeds, \Server{} removes the entry from\\$RegistrationCodeMap$.
  \item If the checks fails, \Server{} sends error to the entity that requested the check and terminates the flow.
 \end{enumerate}
\end{enumerate}

\subsubsection{Flow Termination with Error on Failed Commit}
Steps which state that entity $X$ commits $Y$ to the DB imply a flow branch that is followed when the commit operation fails. In this case, $X$ terminates the flow with an error. 
In most cases, error flows are inferable from other error branches. When this is not possible, the branch is declared explicitly. 

\subsubsection{\Server{} Errors}
All flows involving \Server{} and another entity may fail for various reasons, such as \userId{} or \clientId{} being unknown or the signature verification failing. For security, 
\Server{} does not reveal the specific reason the operation failed. Therefore, when, for example, a registration code verification fails, the message from \Server{} to \Client{} 
does not differentiate between all the reasons the verification may fail.

\subsection{User Registration}

\paragraph{Description}
This protocol covers the flow where a user registers for the first time. The flow registers implicitly the client from which the registration took place.

\paragraph{Participants} \Server{}, \Client{}, \User{}

\paragraph{Inputs}
\SpecialItem
\begin{description}
 \item[\handle{}:$\langle$ Handle $\rangle$]
\end{description}

\paragraph{Outputs}
For \Client{} either success, if the user was registered successfully, or error if the user information is invalid or the user handle already exists.

\paragraph{Other Variables}
\SpecialItem
\begin{description}
 \item[\registrationCode{}:registration code]
 \item[\userAgent{}:UserAgent] This is produced by \Client{} and contains software and platform information.
 \item[\privateKeys{}:PrivateKeys] Generated by \Client{}.
 \item[\publicKeys{}:PublicKeys] Generated by \Client{}.
 \item[\userId{}:Id] The internal user id. We cannot use \handle{}, because it may change in the lifetime of an account. Generated by \Server{}.
 \item[\clientId{}:Id] The client id, generated by \Server{}.
 \item[\loggedIn{}:boolean] A flag indicating whether at \Client{} startup \Client{} transitions to the main screen or a log-in screen.
\end{description}

\paragraph{Flow}

\begin{enumerate}\label{user_registration_flow}
 \item\label{user_registration_flow:first} \Client{} requests \User{} to populate \handle{}.
 \item \User{} populates \handle{}.
 \item \Client{} stores \handle{} in secure local storage.
 \item \Client{} populates \userAgent{}, \publicKeys{} and \privateKeys{}{\userAgent{} is constructed at every client start, because the data may change due to OS or client 
upgrades.}.
 \item \Client{} stores \privateKeys{} to secure local storage\footnote.
 \item \Client{} sends \handle{}, \userAgent{} and \publicKeys{} to \Server{}.
 \item\label{user_registration_flow:fifth} \Server{} verifies the integrity of the received data and whether \handle{} is new to the system.
 \begin{enumerate}
  \item If the above step fails, \Server{} sends an error message to \Client{} and the flow terminates.
 \end{enumerate}
 \item\label{user_registration_flow:sixth} \Server{} generates \registrationCode{}, \userId{} and \clientId{}.
 \item\label{user_registration_flow:seventh} \Server{} commits \registrationCode{}, \userId{}, \clientId{}, \handle{}, \publicKeys{} and \userAgent{} to the DB.
 \item \Server{} sends \userId{} and \clientId{} to \Client{}.
 \item\label{user_registration_flow:second} \Client{} stores \userId{} and \clientId{} to secure local storage.
 \item \Client{} removes \handle{} from storage.
 \item \Server{} sends \registrationCode{} to \handle{}.
 \item\label{user_registration_flow:eighth} \User{} enters \registrationCode{} to \Client{}.
 \item\label{user_registration_flow:third} \Client{} sends \userId{}, \clientId{} and \registrationCode{} signed with \signingKey{} to \Server{}.
 \item \Server{} verifies that \registrationCode{} corresponds to \userId{} and \clientId{} to the DB and the signature is verified.
 \begin{enumerate}
  \item If the above check fails, \Server{} sends an error message to \Client{} and the flow terminates.
 \end{enumerate}
 \item\label{user_registration_flow:fourth} \Server{} marks $\langle$\userId{}, \clientId{}$\rangle$ as registered.
 \item \Client{} sets \loggedIn{} to true and stores it in secure storage.
\end{enumerate}

\subparagraph{Atomicity}
In the above flow there are two sections where if the connection between \Server{} and \Client{} fails, the whole section needs to repeated from the beginning. These sections are 
steps \ref{user_registration_flow:first}-\ref{user_registration_flow:second}, inclusive, and \ref{user_registration_flow:third}-\ref{user_registration_flow:fourth}, inclusive. In 
case of failure, \Server{} reverts any changes to the DB and \Client{} repeats the process with data that have been stored locally. For the first section \Client{} needs \handle{} 
and for the second \userId{} and \clientId{} from local storage and \registrationCode{} to be reentered by \User{}.

\subsection{Device Registration}

\paragraph{Description}
The device registration flow is similar to the user registration flow. The use case is a user that already exists wants to use their account on another device.

\paragraph{Participants} \Server{}, \Client{}, \User{}

\paragraph{Inputs}
\SpecialItem
\begin{description}
 \item[\handle{}:Handle]
\end{description}

\paragraph{Outputs}
For \Client{} either success, if the client was registered successfully, or error if the user information is invalid or the user handle doesn't already exists.

\paragraph{Other Variables}
\SpecialItem
\begin{description}
 \item[\registrationCode{}:registration code]
 \item[\userAgent{}:UserAgent] This is produced by \Client{} and contains software and platform information.
 \item[\privateKeys{}:PrivateKeys] Generated by \Client{}.
 \item[\publicKeys{}:PublicKeys] Generated by \Client{}.
 \item[\userId{}:Id] The internal user id. We cannot use \handle{}, because it may change in the lifetime of an account. Generated by \Server{}.
 \item[\clientId{}:Id] The client id, generated by the server.
\end{description}

\paragraph{Flow}

\begin{enumerate}\label{device_registration_flow}
 \item\label{device_registration_flow:first} \Client{} requests \User{} to populate \handle{}.
 \item \User{} populates \handle{}.
 \item \Client{} stores \handle{} in secure local storage.
 \item \Client{} populates \userAgent{}, \publicKeys{} and \privateKeys{}{\userAgent{} is constructed at every client start, because the data may change due to OS or client 
upgrades.}.
 \item \Client{} stores \privateKeys{} to secure local storage\footnote.
 \item \Client{} sends \handle{}, \userAgent{} and \publicKeys{} to \Server{}.
 \item\label{device_registration_flow:fifth} \Server{} verifies the integrity of the received data and whether \handle{} exists.
 \begin{enumerate}
  \item If the above step fails, \Server{} sends an error message to \Client{} and the flow terminates.
 \end{enumerate}
 \item\label{device_registration_flow:retrieve} \Server{} retrieves \userId{} from \handle{}.
 \item\label{device_registration_flow:sixth} \Server{} generates \registrationCode{} and \clientId{}.
 \item\label{device_registration_flow:seventh} \Server{} commits \registrationCode{}, \clientId{}, \handle{}, \publicKeys{} and \userAgent{} to the DB.
 \item \Server{} sends \userId{} and \clientId{} to \Client{}.
 \item\label{device_registration_flow:second} \Client{} stores \userId{} and \clientId{} to secure local storage.
 \item \Client{} removes \handle{} from storage.
 \item \Server{} sends \registrationCode{} to \handle{}.
 \item\label{device_registration_flow:eighth} \User{} enters \registrationCode{} to \Client{}.
 \item\label{device_registration_flow:third} \Client{} sends \userId{}, \clientId{} and \registrationCode{} signed with \signingKey{} to \Server{}.
 \item \Server{} verifies that \registrationCode{} corresponds to \userId{} and \clientId{} in its DB and the signature is verified.
 \begin{enumerate}
  \item If the above check fails, \Server{} sends an error message to \Client{} and the flow terminates.
 \end{enumerate}
 \item\label{device_registration_flow:fourth} \Server{} marks $\langle$\userId{}, \clientId{}$\rangle$ as registered.
 \item \Client{} sets \loggedIn{} to true and stores it in secure storage.
 \item \Client{} displays to \User{} that registration succeeded.
\end{enumerate}

\subparagraph{Atomicity}
In the above flow there are two sections where if the connection between \Server{} and \Client{} fails, the whole section needs to repeated from the beginning. These sections are 
steps \ref{device_registration_flow:first}-\ref{device_registration_flow:second}, inclusive, and \ref{device_registration_flow:third}-\ref{device_registration_flow:fourth}, 
inclusive. In case of failure, \Server{} reverts any changes to the DB and \Client{} repeats the process with data that have been stored locally. For the first section \Client{} 
needs \handle{} and for the second \userId{} and \clientId{} from local storage and \registrationCode{} to be reentered by \User{}.

\paragraph{Implementation Notes}
User and device registration flows are almost identical. The differences are:

\begin{itemize}
 \item In step \ref{user_registration_flow}.\ref{user_registration_flow:fifth}, the check for is whether \handle{} does not exist. In step 
\ref{device_registration_flow}.\ref{device_registration_flow:fifth}, the check is whether \handle{} exists. This check can be implemented as a pure virtual method in the base 
class and the two flows can share the flow code.
 \item In step \ref{user_registration_flow}.\ref{user_registration_flow:sixth} \userId{} is generated, which doesn't happen in step 
\ref{device_registration_flow}.\ref{device_registration_flow:sixth}. Similarly, in step \ref{user_registration_flow}.\ref{user_registration_flow:seventh} \Server{}
creates a new user and adds a client to its list, while in step \ref{device_registration_flow}.\ref{device_registration_flow:seventh} \Server{} adds a client to the user retrieved 
in step \ref{device_registration_flow}.\ref{device_registration_flow:retrieve}. The different actions can be plugged in a common flow code.
 \item From the perspective of \Client{}, the steps after \ref{user_registration_flow}.\ref{user_registration_flow:eighth} and 
\ref{device_registration_flow}.\ref{device_registration_flow:eighth} are identical and can be implemented as the same UI flow.
\end{itemize}

\subsection{Log out Client}
\label{log_out_client_flow}
The client transitions to the log in screen. The client needs to log in again with a registration code to be used.

\paragraph{Participants} \Client{}, \User{}

\paragraph{Inputs}
None. This flow is triggered from an option in settings.

\paragraph{Outputs}
None. \Client{} transitions to the log in screen.

\paragraph{Other Variables}
None.

\paragraph{Flow}

\begin{enumerate}
 \item \User{} requests to log out.
 \item \Client{} sets its login state to false in secure local storage.
\end{enumerate}

\paragraph{Alternative Flow}
\label{log_out_client_flow:alternative}

This flow removes the keys as well as setting the login state to false. If this flow is implemented, flow \ref{log_in_client_flow} needs to be modified to generate a key pair. See 
\ref{log_in_client_flow:alternative} for details. In this case the flow is extended as:

\begin{enumerate}[resume]
 \item \Client{} removes \privateKeys{} from its local storage.
\end{enumerate}

The security/usability trade-off is:

\begin{itemize}
 \item With the original flow, there is the option to strengthen authentication by requiring that during registration a key needs to be imported through a third channel. For 
example, in case of a B2B deployment, an organization could issue a QR code that is delivered to the user by hand and it needs to be scanned before a new device is registered. All 
subsequent keys are strongly authenticated transitively. If a user loses the key (due to the client having been uninstalled or a client malfunction), the device registration flow 
needs to be restarted.

The security impact is that logging out leaves the keys alive and an attacker can flip the logged in state and use the client. Therefore, logout should be interpreted as 
protection against only casual attacks.
\item With the alternative flow, logging out is impervious to stronger attackers, since the keys are not there anymore. However, it is not possible to strengthen the 
authentication flow, because logging in would require a time-consuming device registration.
\end{itemize}

The alternative flow may be implemented in the future, if customer requirements favor stronger security guarantees for the logged out state.

\subsection{Log in Client}
\label{log_in_client_flow}
This flow is triggered when the client starts and it finds \userId{} and \clientId{} in its local storage and \loggedIn{} is either false or missing. In this case, the user is 
presented with an option to log in with a registration code or register as a new user or a new client, in which case flows \ref{user_registration_flow} and 
\ref{device_registration_flow} are triggered respectively.

\paragraph{Participants} \Client{}, \Server{}, \User{}

\paragraph{Inputs}
\SpecialItem
\begin{description}
 \item[\userId{}:Id] From \Client{} local storage.
 \item[\clientId{}:Id] From \Client{} local storage.
\end{description}

\paragraph{Outputs}
For \Client{} either success, if the client registered successfully, or error if the server rejects the request or the registration code is wrong. In case of success, \Client{} 
transitions to the main screen. In case of error, the client restarts the flow.

\paragraph{Other Variables}
\SpecialItem
\begin{description}
 \item[\loggedIn{}:boolean] Stored in secure storage.
 \item[\handle{}:Handle]
 \item[\registrationCode{}:registration code]
\end{description}

\paragraph{Flow}

\begin{enumerate}
 \item \User{} requests a log in registration code.
 \item \Client{} retrieves \userId{} and \clientId{}.
 \item \Client{} sends \userId{} and \clientId{} to \Server{}.
 \item \Server{} checks if \userId{} and \clientId{} exist in its DB.
 \begin{enumerate}
  \item If the client doesn't exist, \Server{} replies with an error and the flow terminates.
 \end{enumerate}
 \item \Server{} retrieves \handle{} for \userId{}.
 \item \Server{} generates \registrationCode{} and commits it to the DB.
 \item \Server{} sends \registrationCode{} to \handle{}.
 \item \User{} enters \registrationCode{} to \Client{}.
 \item\label{log_out_client_flow:one} \Client{} sends \registrationCode{} signed with \signingKey{}, \userId{} and \clientId{} to \Server{}.
 \item \Server{} checks that \registrationCode{} is valid and verifies the signature.
 \begin{enumerate}
  \item If the check fails, \Server{} replies with an error and the flow terminates.
 \end{enumerate}
 \item \Client{} sets \loggedIn{} to true and stores it in secure local storage.
\end{enumerate}

\paragraph{Alternative Flow}
\label{log_in_client_flow:alternative}

This is to be implemented if \ref{log_out_client_flow:alternative} is implemented. The steps replace steps from \ref{log_out_client_flow:one} until the end of the flow.

\begin{enumerate}
 \item \Client{} populates \publicKeys{} and \privateKeys{}.
 \item \Client{} sends \registrationCode{} signed with \signingKey{}, \userId{} and \clientId{} to \Server{}.
 \item \Server{} checks that \registrationCode{} is valid and verifies the signature.
 \begin{enumerate}
  \item If the check fails, \Server{} replies with an error and the flow terminates.
 \end{enumerate}
 \item \Client{} sets \loggedIn{} to true and stores it in secure local storage.
 \item \Client{} stores \privateKeys{} its secure local storage.
\end{enumerate}

\subsection{Modify Keys}
\label{modify_keys_flow}
This flow is triggered periodically from the client. For details about when it is triggered see \cite{crypto_spec}.

\paragraph{Participants} \Client{}, \Server{}

\paragraph{Inputs}
\SpecialItem
\begin{description}
 \item[\userId{}:Id] From \Client{} local storage.
 \item[\clientId{}:Id] From \Client{} local storage.
 \item[\privateKeys{}:PrivateKeys] The private keys that are valid at the start of the flow. From \Client{} local storage.
\end{description}

\paragraph{Outputs}
For \Client{} either success, if \Server{} applied the changes, error otherwise. In case of error, the new keys are discarded and the flow is repeated according to the 
specification in \cite{crypto_spec}.

\paragraph{Other Variables}
\SpecialItem
\begin{description}
 \item[\newPrivateKeys{}:PrivateKeys] The new private keys.
 \item[\newPublicKeys{}:PublicKeys] The new public keys.
 \item[\signedData{}:ECDSA signature] The ECDSA signature of \newPublicKeys{} with \signingKey{}. See \cite{crypto_spec} for details.
 \item[\publicKeys{}:PublicKeys] The public keys of \Client{} stored in the DB of \Server{}.
\end{description}

\paragraph{Flow}

\begin{enumerate}
 \item \Client{} constructs \newPrivateKeys{}, \newPublicKeys{}.
 \item \Client{} generates \signedData{}.
 \item \Client{} sends \signedData{}, \newPublicKeys{}, \userId{} and \clientId{} to \Server{}.
 \item \Server{} retrieves \publicKeys{} based on \userId{} and \clientId{}.
 \item \Server{} verifies the signature of \signedData{}.
 \begin{enumerate}
  \item If the above step fails, \Server{} replies with error.
 \end{enumerate}
 \item \Server{} verifies the integrity of \newPublicKeys{}.
 \begin{enumerate}
  \item If the above step fails, \Server{} replies with error.
 \end{enumerate}
 \item \Server{} commits \newPublicKeys{} to the DB.
 \item \Server{} replies with success.
 \item\label{modify_keys_flow:local_storage} \Client{} commits \newPrivateKeys{} to secure local storage.
\end{enumerate}

\subsection{Modify User Agent}
\label{modify_user_agent_flow}
This flow is triggered when the user agent has changed, due to client or OS updates. The flow is identical to \ref{modify_keys_flow}, with the difference that \signedData{} 
signs the new user agent, instead of \newPublicKeys{}. The implementation must be common, parameterized for the input data.

This flow does not require a registration code, as the effects are reversible and the \handle{} information does not change.

\subsection{Modify Handle}
This flow is triggered when \User{} requests a \handle{} change.

\paragraph{Participants} \Client{}, \Server{}, \User{}

\paragraph{Inputs}
\SpecialItem
\begin{description}
 \item[\userId{}:Id] From \Client{} local storage.
 \item[\clientId{}:Id] From \Client{} local storage.
 \item[\newHandle{}: Handle] The replacement value for \handle{}, entered by \User{}.
\end{description}

\paragraph{Outputs}
For \Client{} either success, if \handle{} changed successfully, or error if the server rejects the request or the registration code is wrong.

\paragraph{Other Variables}
\SpecialItem
\begin{description}
 \item[\handle{}:Handle]
 \item[\registrationCode{}:registration code]
 \item[\signingKey{}:ECDSA signing key] From \Client{} local storage.
 \item[\verificationKey{}:ECDSA verification key] From \Server{} DB.
 \item[\signedData{}:ECDSA signature] \newHandle{} signed with \signingKey{}.
\end{description}

\paragraph{Flow}

\begin{enumerate}
 \item \User{} enters \newHandle{}.
 \item \Client{} retrieves \signingKey{}, \userId{} and \clientId{}.
 \item \Client{} produces \signedData{} from \newHandle{} and \signingKey{}.
 \item \Client{} sends \signedData{}, \userId{} and \clientId{} to \Server{}.
 \item \Server{} checks if \userId{} and \clientId{} exist in its DB.
 \begin{enumerate}
  \item If the client doesn't exist, \Server{} replies with an error and the flow terminates.
 \end{enumerate}
 \item \Server{} retrieves \verificationKey{} for \userId{}.
 \item \Server{} verifies the signature of \signedData{} and retrieves \newHandle{}.
 \item \Server{} generates \registrationCode{} and commits it to the DB.
 \item \Server{} sends \registrationCode{} to \newHandle{}.
 \item \User{} enters \registrationCode{} to \Client{}.
 \item \Client{} sends \registrationCode{} signed with \signingKey{}, \userId{} and \clientId{} to \Server{}.
 \item \Server{} checks that \registrationCode{} is valid and the signature is correct.
 \begin{enumerate}
  \item If the check fails, \Server{} replies with an error and the flow terminates.
 \end{enumerate}
 \item \Server{} replies to \Client{} with success.
 \item \Client{} sets \handle{} to \newHandle{}.
\end{enumerate}

\subsection{Test Public Keys}
\label{test_public_keys_flow}
This flow is triggered when there is reason to believe that the public keys stored in \Server{} are out-of-sync with the private keys stored in \Client{}. An example of such a 
case is \ref{modify_keys_flow}.\ref{modify_keys_flow:local_storage} failed and the client crashed before it could repeat the flow and recover. The flow can be triggered 
automatically by \Client{} or by \User{} when there is some suspicion that the keys are invalid. For the purposes of this flow we assume \Client{} triggers it. In case the flow 
terminates with error, the client logs out.

\paragraph{Participants} \Client{}, \Server{}

\paragraph{Inputs}
\SpecialItem
\begin{description}
 \item[\userId{}:Id] From \Client{} local storage.
 \item[\clientId{}:Id] From \Client{} local storage.
 \item[\privateKeys{}:PrivateKeys] From \Client{} local storage.
\end{description}

\paragraph{Outputs}
For \Client{} either success, if \Server{} reports that the public key it holds is valid, error otherwise. In case of error, the flow in \ref{reset_public_key_flow} is expected to 
be triggered.

\paragraph{Other Variables}
\SpecialItem
\begin{description}
 \item[\publicKeys{}:PublicKeys] The public keys of \Client{} stored in the DB of \Server{}.
 \item[\fixedString{}: string] Random string that is used as plaintext payload between \Server{} and \Client{}.
 \item[\signedData{}:ECDSA signature] The ECDSA signature of \fixedString{} with \signingKey{}. See \cite{crypto_spec} for details.
 \item[\encryptedData{}:ECDH signature] The ECDSA signature of \fixedString{} with \signingKey{}. See \cite{crypto_spec} for details.
 \item[\serverVerified{}:boolean]
\end{description}

\paragraph{Flow}

\begin{enumerate}
 \item \Client{} generates \fixedString{}.
 \item \Client{} sends \userId{}, \clientId{} and \fixedString{} to \Server{}.
 \item \Server{} populates \encryptionKey{} from \userId{} and \clientId{}.
 \item \Server{} generates \encryptedData{} from \fixedString{} and \encryptionKey{}.
 \item \Server{} sends \encryptedData{} to \Client{}.
 \item \Client{} verifies the encryption of \fixedString{} from \encryptedData{} and \decryptionKey{}.
 \item \Client{} generates \signedData{} from \fixedString{} with \signingKey{}.
 \item \Client{} sends \userId{}, \clientId{}, \fixedString{} and \signedData{} to \Server{}.
 \item \Server{} populates \verificationKey{} from \userId{} and \clientId{}.
 \item \Server{} verifies the signature of \signedData{} from \fixedString{} and \signingKey{} and sets \serverVerified{} to the result.
 \item \Server{} sends \serverVerified{} to \Client{}.
 \item \Client{} terminates the flow with success or error according to \serverVerified{}.
 \begin{enumerate}
  \item If \serverVerified{} is false, \Client{} sets its login state to false in secure local storage.
 \end{enumerate}
\end{enumerate}

\subsection{Reset Public Key}
\label{reset_public_key_flow}
This flow is triggered when the flow in \ref{test_public_keys_flow} terminated with error.

\paragraph{Participants} \Client{}, \Server{}, \User{}

\paragraph{Inputs}
\SpecialItem
\begin{description}
 \item[\userId{}:Id] From \Client{} local storage.
 \item[\clientId{}:Id] From \Client{} local storage.
\end{description}

\paragraph{Outputs}
For \Client{} either success, if \Server{} reports that the public key has 
been reset successfully, or error otherwise. In case of error, the flow is 
expected to be repeated.

\paragraph{Other Variables}
\SpecialItem
\begin{description}
 \item[\publicKeys{}:PublicKeys] The newly generated public keys of 
\Client{}. 
 \item[\privateKeys{}:PrivateKeys] The newly generated private keys of 
\Client{}.
 \item[\registrationCode{}:registration code]
 \item[\signedData{}:ECDSA signature] \registrationCode{} signed with
\privateKeys{}. See \cite{crypto_spec} for details.
 \item[\handle{}:Handle]
 \item[\serverVerified:boolean]
\end{description}

\paragraph{Flow}

\begin{enumerate}
 \item \User{} requests resetting the public key.
 \item \Client{} sends to \Server{} \userId{} and \clientId{}.
 \item \Server{} retrieves \handle{} based on \userId.
 \item \Server{} generates \registrationCode{} and commits it to the DB.
 \begin{enumerate}
  \item If the above step fails, \Server{} terminates the flow. \Client{} is 
not notified. \User{} will have to trigger the flow again.
 \end{enumerate}
 \item \User{} enters \registrationCode{} to \Client{}.
 \item \Client{} generates \publicKeys{} and \privateKeys{}.
 \item \Client{} commits \privateKeys{} to its DB.
 \item \Client{} generates \signedData{} from \registrationCode{}, 
\privateKeys{}.
 \item \Client{} sends \publicKeys{} and \signedData{} to \Server{}.
 \item \Server{} verifies that \signedData{} is \registrationCode{} signed 
with \publicKeys{}. The result of the operation is assigned to \serverVerified{}.
 \item \Server{} sends \serverVerified{} to \Client{}.
 \item \Client{} terminates the flow according to the result of 
\serverVerified{}.
 \begin{enumerate}
  \item If the result is false, \privateKeys{} is removed from its secure local 
storage.
 \end{enumerate}
\end{enumerate}

\subsection{Delete Client}
This flow deletes client information from the server and logs out the client. 
When the last client is deleted for a user, the user information is deleted 
from the server as well.

\paragraph{Participants} \Client{}, \Server{}, \User{}

\paragraph{Inputs}
\SpecialItem
\begin{description}
 \item[\userId{}:Id] From \Client{} local storage.
 \item[\clientId{}:Id] From \Client{} local storage.
\end{description}

\paragraph{Outputs}
For \Client{} either success, if \Server{} deleted \Client{} successfully, 
error otherwise. If the flow failed, \Client{} stays active.

\paragraph{Other Variables}
\SpecialItem
\begin{description}
 \item[\publicKeys{}:PublicKeys] The newly generated public keys of 
\Client{}. 
 \item[\privateKeys{}:PrivateKeys] The newly generated private key of
\Client{}.
 \item[\registrationCode{}:registration code]
 \item[\signedData{}:ECDSA signature] \registrationCode{} signed with
\privateKeys{}. See \cite{crypto_spec} for details.
 \item[\handle{}:Handle]
 \item[\removeUser:boolean] Whether the user account is to be removed.
\end{description}

\paragraph{Flow}

\begin{enumerate}
 \item \User{} requests \Client{} be deleted.
 \item \Client{} sends \userId{} and \clientId{} to \Server{}.
 \item \Server{} retrieves \handle{} from its DB based on \userId{} and 
\clientId{}.
 \item \Server{} generates \registrationCode{}.
 \item \Server{} sends \registrationCode{} to \handle{}.
 \item \User{} enters \handle{} to \Client{}.
 \item \Client{} generates \signedData{} from \registrationCode{}, 
\privateKeys{}.
 \item \Client{} sends \signedData{}, \userId{}, \clientId{} to \Server{}.
 \item \Server{} retrieves \publicKeys{} from its DB based on \userId{} and 
\clientId{}.
 \item \Server{} verifies \registrationCode{} based on its DB and \publicKeys{}.
 \begin{enumerate}
  \item If the above step failed, \Server{} sends error to \Client{}.
  \item \Client{} terminates the flow.
 \end{enumerate}
 \item \Server{} checks if \clientId{} is that last entry in $UserSet.clients$.
 \begin{enumerate}
  \item If it is not, \Server{} sets \removeUser{} and goes to 
step \ref{delete_client:first}.
  \item If it is, \Server{} sends to \Client{} a request to remove the entire 
user account.
  \item \Client{} asks \User{} about whether the account can be removed.
  \item \User{} answers the query.
  \item \Client{} sets the value of \removeUser{} according to the answer by 
\User{}.
  \item{} \Client{} sends \removeUser{}, \userId{} and \clientId{} to 
\Server{}, signed with \privateKeys{}.
  \item{} \Server{} verifies the signature of \removeUser{} and sets the value 
of \removeUser{}.
  \begin{enumerate}
   \item If the signature verification fails, \Server{} sends \Client{} an 
error.
   \item \Client{} terminates the flow with error.
  \end{enumerate}
 \end{enumerate}
 \item\label{delete_client:first} \Server{} removes from $UserSet.clients$ the 
entry for \clientId{}.
 \item If \removeUser{} is true, \Server{} removes \userId{} from $UserSet$.
 \item \Server{} sends success to \Client{}.
 \item \Client{} removes \clientId{} and \privateKeys{} from its DB.
 \item \Client{} sets \loggedIn{} to false and commits it to local storage.
\end{enumerate}

\subsection{Signature Verification Failure}
\label{signature_failed_flow}
The purpose of this flow is to notify the user that a purchase order cannot be 
executed because the signature cannot be verified. The flow is informative for 
\User{}; \Client{} shows the appropriate error message in case 
 fails.

The assumption for this flow is that \Server{} is able to extract enough 
information from the message from the \Client{} to construct a purchase order 
and create $receipt$. If the message is corrupted to the point that the client 
cannot be identified, the flow is not executed.

\paragraph{Participants} \Server{}

\paragraph{Inputs}
\SpecialItem
\begin{description}
 \item[receipt: Receipt] The receipt structure generated by \Server{} for the 
failed purchase order.
\end{description}

\paragraph{Outputs}
A message sent to $receipt.handle$. The message format is specified 
in \cite{UI_spec}.

\paragraph{Other Variables}
\SpecialItem
\begin{description}
 \item[message: string] The message to be sent out.
\end{description}

\paragraph{Flow}

\begin{enumerate}
 \item \Server{} generates $message$ from $receipt$.
 \item \Server{} sends $message$ to $receipt.handle$.
\end{enumerate}

\subsection{Replay Attack Detected}
\label{replay_attack_flow}
This is a sub-flow triggered when \Server{} detects that a purchase order by 
\Client{} has a sequence number that is smaller than or equal to the one stored 
in the DB for \Client{}. There are two scenarios the can trigger a replay 
attack flow:

\begin{enumerate}
 \item The keys of \Client{} have been leaked and a malicious attacker 
generates purchase orders with the keys. At the same time \Client{} generates 
orders using the same sequence numbers. In this case, \Server{} deletes 
\Client{} from its DB and sends out a warning using channels other than 
\Client{}.

There is a chance that this case is triggered by a \Client{} malfunction 
(sequence number gets corrupted). In this case the \Client{} cannot function 
anyway and \User{} needs to re-register.
\end{enumerate}

\paragraph{Participants} \Server{}

\paragraph{Inputs}
\SpecialItem
\begin{description}
 \item[userId:Id] The user id.
 \item[clientId:Id] The client id.
 \item[purchaseOrder:PurchaseOrder] The purchase order that triggered the 
replay attack flow.
 \item[retailer:Retailer] The retailer that forwarded the order.
\end{description}

\paragraph{Outputs}
If the receipt generated by the replayed purchase order is equal to the stored 
receipt, no action is taken. If the receipts do not match, a message is sent to 
\User{} and \Client{} that the account has been deleted because \Client{} 
keys have been compromised. This message is delivered via a push notification, 
because \Client{} cannot be trusted anymore to pull messages.

Further counter-measures for retailers that are flagged for repeated replay 
attacks will be defined.

\paragraph{Other Variables}
\SpecialItem
\begin{description}
 \item[handle:Handle] The handle mapped to \userId{} and \clientId{}.
 \item[receiptOld:Server.Receipt] The stored receipt corresponding to the 
already seen payment.
 \item[receiptNew:Server.Receipt] The new receipt generated by the incoming 
purchase order.
 \item[message1:string] The message that is sent to \handle{}.
 \item[message2:string] The message sent to \Client{}.
 \item[codeOld:bytearray] The barcode for $receiptOld$.
 \item[codeNew:bytearray] The barcode for $receiptNew$.
\end{description}

\paragraph{Flow}

\begin{enumerate}
 \item \Server{} populates $receiptOld$ by retrieving it from the $ReceiptSet$ 
table based on \userId{}, \clientId{} and $purchaseOrder.sequenceNumber$.
 \item \Server{} populates $receiptNew$ based on \userId{}, \clientId{}, 
$retailer$ and $purchaseOrder$.
 \item \Server{} populates $codeOld$ based on $receiptOld.clientId$ and
$receiptOld.purchaseId$.
 \item \Server{} populates $codeNew$ from $purchaseOrder$.
 \item \Server{} compares $codeOld$ to $codeNew$.
 \begin{enumerate}
  \item If they are equal, the flow finishes.
 \end{enumerate}
 \item \Server{} populates \handle{}, based on \userId{} and \clientId{}.
 \item \Server{} populates $message1$ based on $receiptNew$. The format of the 
message is defined in \cite{UI_spec}.
 \item \Server{} sends $message1$ to \handle{}.
 \item \Server{} populates $message2$ based on \handle{}. The format of the 
message is defined in \cite{UI_spec}.
 \item \Server{} sends $message2$ via a push notification.
 \item \Server{} deletes the client entry in $UserSet$ corresponding to 
\userId{} and \clientId{}.
\end{enumerate}

\bibliography{spec}
\bibliographystyle{plain}

\end{document}
